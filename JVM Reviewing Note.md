##### 双亲委派模型

- 除了顶层（启动类加载器）加载器外，其余加载器都应有父类加载器，父子关系一般使用组合的方式实现
- 工作流程是：当一个类加载器收到类加载请求，它自己不会去先加载这个类，而是把请求委派到父类加载器中，所有的类加载请求都会传到顶层的启动类加载器中，只有当父类反馈无法加载该类的时候，子类才会尝试自己去加载
- **双亲委派模型被破坏**
  - `ClassLoader`在`JDK1.0`的时候就已经存在了，当时继承`ClassLoader`的唯一目的就是重写`loadClass`，而符合双亲委派模型逻辑的流程应该是，先调用父类的`loadClass`，若父类为空则默认使用启动类加载器，父类抛出`ClassNotFundException`之后再调用自己的`findClass`
  - 存在父类加载器依赖子类加载器的情况，于是`Java`引入了*线程上下文类加载器*，这个行为打通了整个结构逆向调用了
  - 由于要实现热部署，热替换，双亲委派模型的树状结构，进一步发展成更复杂的网状结构