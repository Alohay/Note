##### Java 内存区域

- 程序计数器
  - 程序计数器是内存中较小的一块区域，可以看做是当前线程的所运行的字节码的行号指示器，`Java`多线程是通过线程轮流切换分配时间片运行的，为了线程切换后能正确的继续运行，所以每个线程都应当有一个独立的程序计数器，故该程序计数器是线程私有的，值得一提的是，如果当前运行的是`Native` 方法，则计数器的值为空，而且这块内存区域是唯一一块在`Java`虚拟机规范中没有规定`OOM ERROR`的区域
- `Java`虚拟机栈
  - `Java`虚拟机栈也是线程私有的，它描述的是`Java方法执行的内存模型`，当一个方法调用时会同时创建一个栈帧，一个方法的调用到执行完成，对应的就是一个栈帧的入栈和出栈，栈帧中包含局部变量表，操作数栈等信息，局部变量表中存储了编译期间可知的基本类型（8种），对象的引用，返回地址类型。局部变量表的大小在运行期间是不会改变的，一但分配完成就确定了。
- 本地方法栈
  - 跟`Java`虚拟机栈的作用差不多，不过是服务于本地方法
- `Java`堆
  - 内存区域中最大的一块，线程共有，几乎所有的对象都在这块区域分配内存，尽管`Java`虚拟机规范规定所有的对象实例和数组都要在堆上分配，但由于`JIT`编译器及逃逸分析技术的逐渐成熟，这条规定变得不那么绝对了
  - 这块区域是垃圾收集器管理的主要区域，按**内存回收**角度，分成新生代，老年代，再细分新生代还可以分成`Eden`,`From Survivor`,`To Survivor`；按**内存分配**角度，分成多个线程私有的分配缓冲区
- 方法区
  - 存储已被虚拟机加载的类信息，静态变量，常量，编译生成的代码等数据
  - 方法区内有一块运行时常量池，存储了`Class`文件中常量池对应的内容，编译期间生成的各种字面量和符号引用，程序运行期间产生的常量也是放在这里的，例如`String`的`itern()`方法

##### 对象创建

- 先找到相应的类的符号引用，检查是否加载的对应的类
- 分配内存
  - 指针碰撞方法，带有压缩过程的收集器使用这种，用了的内存和没用的内存分布在两边，分配内存时，移动一下中间指针的位置
  - 空闲表法，选一块足够大的内存分配，一般`Mark And Sweep`收集器采用这种
- 保证分配内存的线程安全
  - `CAS`失败重试
  - 线程分配缓冲区，每个线程都预先分配一块小内存，分配对象直接分配到该内存上，等要`resize`时才同步锁定
- 对象产生
  - `GC`分代年龄，对象是那个类的对象实例，对象的哈希码等等，虚拟机的角度，此时一个对象已经产生，但是从`Java`程序的角度来说，对象的属性值都是默认值，还没有执行初始化方法

##### 类加载

- 类加载到内存到卸载出内存，生命周期
  - 加载
    - 通过类的全限定名获取相应的二进制字节流
    - 将类的静态存储结构转化成方法区的运行时数据结构
    - 在内存中生成代表这个类的`Class`对象（作为方法区这个类的各种数据的访问入口
  - 验证
    - 静态文件验证
      - 校验二进制字节流的合法性，如开头的魔数，版本号是否在虚拟机可处理范围内，常量池常量中是否有不被支持的类型
    - 方法区存储结构验证
      - 元数据验证，语义分析
      - 字节码验证，保证不会有危害虚拟机的行为
      - 符号引用验证，保证解析动作的正常进行
  - 准备
    - 为类变量分配内存及初始值（初始值为默认值，若`final`修饰，则为具体值）
  - 解析
    - 符号引用 `->` 直接引用
  - 初始化 
    - 按程序员意愿初始化类变量和其他资源
  - 使用
  - 卸载 
  - 加载，验证，准备，初始化和卸载**开始的**顺序是确定的
- 类加载时机
  - `main`方法被调用
  - `new`对象
  - 反射
  - 子类初始化，要先初始化父类
  - 静态方法和成员被调用，注意若用`final`修饰，即定义为常量，则不会初始化，因为在编译期间通过常量传播优化，将常量存储到了调用类的常量池中

##### 双亲委派模型

- 除了顶层（启动类加载器）加载器外，其余加载器都应有父类加载器，父子关系一般使用组合的方式实现
- 工作流程是：当一个类加载器收到类加载请求，它自己不会去先加载这个类，而是把请求委派到父类加载器中，所有的类加载请求都会传到顶层的启动类加载器中，只有当父类反馈无法加载该类的时候，子类才会尝试自己去加载
- **双亲委派模型被破坏**
  - `ClassLoader`在`JDK1.0`的时候就已经存在了，当时继承`ClassLoader`的唯一目的就是重写`loadClass`，而符合双亲委派模型逻辑的流程应该是，先调用父类的`loadClass`，若父类为空则默认使用启动类加载器，父类抛出`ClassNotFundException`之后再调用自己的`findClass`
  - 存在父类加载器依赖子类加载器的情况，于是`Java`引入了*线程上下文类加载器*，这个行为打通了整个结构逆向调用了
  - 由于要实现热部署，热替换，双亲委派模型的树状结构，进一步发展成更复杂的网状结构

##### JMM

- 为了屏蔽硬件和操作系统的内存访问差异，实现`Java`在各个平台上都能达到一致的内存访问效果
- 所有线程共享的变量要存储在主内存中，每个线程有自己的工作内存，工作内存保存一份使用到的变量的拷贝，线程对变量的所有操作在工作内存中进行，线程间变量值得传递需要通过主内存来完成
- 8种原子操作
  - `lock, unlock, read, load, use, assgin, store, write`

- 执行这8种操作有一些必须的规则，如`read, load` 和 `store, write`必须成对出现，`assign`操作不允许被丢弃
- 原子性
  - 利用8种原子操作，可以认为基本类型的访问和读写是具有原子性的（`long, double`一个非原子性协定，64位数据类型读写可以是非原子操作，但强烈建议实现成原子操作）
  - 8种原子操作中的`lock, unlock`是无法给用户直接使用的，虚拟机提供了更高层次的字节码`mointorenter, mointorexit`隐式使用这两个操作，在`Java`代码中就是`synchronized`
- 可见性
  - 一个线程修改了共享变量的值，其他线程能够立即得知这个修改
- 有序性
  - 线程内的语句执行有一句话是叫仿佛是串行执行的，线程间通过`volatile, synchronized`来保证有序性

##### Volatile

- 保证修饰的变量的可见性
   每次修改后的值能立即被其他线程知道，但是不能认为是线程安全的，因为仅仅能保证调用的时候去主内存中获取，在工作内存中进行一些计算的时候可能这个值过期了

- 防止指令重排序

  在赋值后多执行一步操作，相当于一个内存屏障，指令重排序不能越过内存屏障

- `load, read` , `store, write` 必须两两连续执行

##### 先行发生原则

- 一个线程中，控制流在前的县发生于后面的操作
- `unlock`先行发生于后面对同一个锁的`lock`
- `volatile`的写先行发生于读
- 线程的`start`先行发生于线程的其他动作
- 线程的所有动作先行发生于线程终止
- 线程的`interrput`先行发生与检测到中断时间的发生
- 一个线程的初始化先行发生于`finalize`方法
- 传递性 `A 先 B``B 先 C`  则`A 先 C`