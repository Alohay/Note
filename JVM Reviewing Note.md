##### Java 内存区域

- 程序计数器
  - 程序计数器是内存中较小的一块区域，可以看做是当前线程的所运行的字节码的行号指示器，`Java`多线程是通过线程轮流切换分配时间片运行的，为了线程切换后能正确的继续运行，所以每个线程都应当有一个独立的程序计数器，故该程序计数器是线程私有的，值得一提的是，如果当前运行的是`Native` 方法，则计数器的值为空，而且这块内存区域是唯一一块在`Java`虚拟机规范中没有规定`OOM ERROR`的区域
- `Java`虚拟机栈
  - `Java`虚拟机栈也是线程私有的，它描述的是`Java方法执行的内存模型`，当一个方法调用时会同时创建一个栈帧，一个方法的调用到执行完成，对应的就是一个栈帧的入栈和出栈，栈帧中包含局部变量表，操作数栈等信息，局部变量表中存储了编译期间可知的基本类型（8种），对象的引用，返回地址类型。局部变量表的大小在运行期间是不会改变的，一但分配完成就确定了。
- 本地方法栈
  - 跟`Java`虚拟机栈的作用差不多，不过是服务于本地方法
- `Java`堆
  - 内存区域中最大的一块，线程共有，几乎所有的对象都在这块区域分配内存，尽管`Java`虚拟机规范规定所有的对象实例和数组都要在堆上分配，但由于`JIT`编译器及逃逸分析技术的逐渐成熟，这条规定变得不那么绝对了
  - 这块区域是垃圾收集器管理的主要区域，按**内存回收**角度，分成新生代，老年代，再细分新生代还可以分成`Eden`,`From Survivor`,`To Survivor`；按**内存分配**角度，分成多个线程私有的分配缓冲区
- 方法区
  - 存储已被虚拟机加载的类信息，静态变量，常量，编译生成的代码等数据
  - 方法区内有一块运行时常量池，存储了`Class`文件中常量池对应的内容，编译期间生成的各种字面量和符号引用，程序运行期间产生的常量也是放在这里的，例如`String`的`itern()`方法

##### 对象创建

- 先找到相应的类的符号引用，检查是否加载的对应的类
- 分配内存
  - 指针碰撞方法，带有压缩过程的收集器使用这种，用了的内存和没用的内存分布在两边，分配内存时，移动一下中间指针的位置
  - 空闲表法，选一块足够大的内存分配，一般`Mark And Sweep`收集器采用这种
- 保证分配内存的线程安全
  - `CAS`失败重试
  - 线程分配缓冲区，每个线程都预先分配一块小内存，分配对象直接分配到该内存上，等要`resize`时才同步锁定
- 对象产生
  - `GC`分代年龄，对象是那个类的对象实例，对象的哈希码等等，虚拟机的角度，此时一个对象已经产生，但是从`Java`程序的角度来说，对象的属性值都是默认值，还没有执行初始化方法

##### 类加载

- 类加载到内存到卸载出内存，生命周期
  - 加载
    - TODO
  - 验证
    - 
  - 准备
  - 解析
  - 初始化 
  - 使用
  - 卸载 
  - 加载，验证，准备，初始化和卸载开始的顺序是确定的，
- 类加载时机
  - `main`方法被调用
  - `new`对象
  - 反射
  - 子类初始化，要先初始化父类
  - 静态方法和成员被调用，注意若用`final`修饰，即定义为常量，则不会初始化，因为在编译期间通过常量传播优化，将常量存储到了调用类的常量池中

##### 双亲委派模型

- 除了顶层（启动类加载器）加载器外，其余加载器都应有父类加载器，父子关系一般使用组合的方式实现
- 工作流程是：当一个类加载器收到类加载请求，它自己不会去先加载这个类，而是把请求委派到父类加载器中，所有的类加载请求都会传到顶层的启动类加载器中，只有当父类反馈无法加载该类的时候，子类才会尝试自己去加载
- **双亲委派模型被破坏**
  - `ClassLoader`在`JDK1.0`的时候就已经存在了，当时继承`ClassLoader`的唯一目的就是重写`loadClass`，而符合双亲委派模型逻辑的流程应该是，先调用父类的`loadClass`，若父类为空则默认使用启动类加载器，父类抛出`ClassNotFundException`之后再调用自己的`findClass`
  - 存在父类加载器依赖子类加载器的情况，于是`Java`引入了*线程上下文类加载器*，这个行为打通了整个结构逆向调用了
  - 由于要实现热部署，热替换，双亲委派模型的树状结构，进一步发展成更复杂的网状结构