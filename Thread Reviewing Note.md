##### Java 线程的实现

- `JDK1.2`之前是使用用户线程实现，后来替换为基于原生线程模型来实现
- `Sun JDK`在`windows, linux`上都是使用的轻量级进程（LWP）实现，一条`Java`线程映射到一个`LWP`中，因为操作系统提供的线程模型就是`1 ：1`

##### 锁

- 自旋锁
  - 请求锁的线程不放弃处理器时间，执行一个或多个忙循环，等共享数据的释放
- 自适应自旋
  - 如果之前通过自旋获得了这个锁，那这次允许多等一会，反之如果很少自旋成功，那么本次知己省略自旋的过程
- 锁消除
  - 虚拟机对于一些检测到一定不存在共享数据竞争的锁进行消除
- 锁粗化
  - 一系列操作对同一个对象反复加锁解锁，把加锁范围扩展到整个操作序列的外部，减少加锁次数
- 轻量级锁
  - 代码进入同步块的时候，如果同步对象没有被锁定，那么就在当前的栈帧中创建一个`Lock Record`存放锁对象头的`Mark Word`的拷贝，然后虚拟机尝试使用`CAS`操作将对象的`Mark Word` 更新为指向`Lock Record`的指针，更新成功则获得锁；失败的话，检查一下是不是指向当前线程的栈帧，如果是，那已经获得了锁，否则说明锁对象已被其他线程抢占。
  - 如果有两个以上的线程争用同一个锁，那就会锁膨胀，轻量级锁变重量级锁
- 偏向锁
  - 当锁对象第一次被获取时，虚拟机把对象头标志位`01`,并使用`CAS`操作将线程的`ID`记录到对象头中，若记录成功，则之后该线程每次进入锁同步块时，虚拟机可以不进行任何同步操作
  - 如果有别的线程尝试获取锁，那么偏向模式就解除了，根据锁对象的状态恢复成未锁定或轻量级锁的状态
  - 如果程序中大多数的锁都是存在竞争的，那么偏向模式就是多余的，禁用锁优化反而可以提高性能

##### Synchronized vs ReentrantLock

- 两者在语义表现上都差不多，都具备一样的线程可重入特性，只是代码写法上有些区别，一个表现为原生语法，一个为`API`，`ReentrantLock`还具备一些高级特性，如等待可中断，实现公平锁，锁可以绑定多个条件

##### 顺序一致性

- 如果程序正确同步，程序执行将具有顺序一致性，就是程序的执行结果和在顺序一致性模型中结果相同
- **顺序一致性模型**
  - 要求所有操作的必须按照程序顺序执行
  - 所有的操作都是原子操作，且能立刻对其他线程可见

##### 线程安全

- `Java`语言中的线程安全其实可以分为5种
  - 不可变，被`final`关键字修饰，只要不可变对象被正确的构造出来，那么其外部状态永远也不会改变，所有线程中都是一致的
  - 绝对线程安全，不管运行环境如何，调用时都不需要额外做同步措施，`Java`的线程安全并没有达到这个级别，而是在次一级别
  - 相对线程安全，保证单次调用的线程安全，如果连续调用，那就需要在操作外部进行同步操作
  - 线程兼容，也就是`Java`中说的线程不安全，通过正确的同步手段保证线程安全
  - 线程对立，例如`Thread's suspend() and resume()`，即使调用时进行了同步操作，仍然有可能产生死锁

##### `long double`非原子性协定

- 在一些32位处理器上要求对64位数据的写具有原子性，会有比较大的开销，允许写操作不具有原子性，一般可能会拆成两个32位的写操作执行，从`JDK5`开始，写仍然可以拆成两步但是读必须具有原子性（读操作必须要在单个事务中执行）

##### Volatile

- 保证修饰的变量的可见性
  每次修改后的值能立即被其他线程知道，但是不能认为是线程安全的，因为仅仅能保证调用的时候去主内存中获取，在工作内存中进行一些计算的时候可能这个值过期了

  - 实现原理是，在写操作后会多出一条`Lock`前缀的汇编指令

    该指令有两个作用，第一将当前处理器缓存行数据写回系统内存，其次该写回操作会无效化其他`CPU`中缓存了该内存地址的数据

    是通过缓存一致性协议实现的，每个处理器会嗅探总线上传播的数据，检查自己缓存的值是不是过期了，发现缓存的缓存行中地址被修改了，就会无效化该缓存，之后要用的时候，就会从系统内存重新获取

- 防止指令重排序

  `volatile读`会在在其后加上`LoadLoad, LoadStore`屏障，不允许后续的任意操作重排序到之前

  `volatile写`会在前面加上`StoreStore`，保证之前的所有普通写操作都已经对其他处理器可见，后面加上`StoreLoad`屏障，保证`volatile` 读后于最后一次写，其实也可以实现为在每个`volatile读`加`StoreLoad`，但是因为一般都是读线程多于写线程，为了执行效率采用在写后加屏障的方案

- `load, read` , `store, write` 必须两两连续执行

##### 先行发生原则

- 一个线程中，控制流在前的县发生于后面的操作
- `unlock`先行发生于后面对同一个锁的`lock`
- `volatile`的写先行发生于读
- 线程的`start`先行发生于线程的其他动作
- 线程的所有动作先行发生于线程终止
- 线程的`interrput`先行发生与检测到中断时间的发生
- 一个线程的初始化先行发生于`finalize`方法
- 传递性 `A 先 B, B 先 C`  则`A 先 C`

##### 线程间通信方式

- 共享内存

  - `Java` 采用的是这种方式，通过读写内存中公共状态进行隐式通信
  - `volatile, CAS, synchronized, ReentrantLock`
    - `volatile`修饰字段，使得所有线程从主内存中获取状态，达到通信得目的
    - `synchronized`同步代码块使用`monitorenter, monitorexit`指令；而同步方法在`class文件`中使用方法修饰符上的一个`ACC_SYNCHRONIZED`标志位来完成；本质都是去获取对象的监视器，因为获取过程是排他的，所以没有获取到的线程会进入一个同步队列，状态变为阻塞状态。每个对象都有自己的监视器，所以每个对象都能当成锁对象。

- 发送消息

  - 线程间通过消息显示进行通信

##### 线程

- 线程是现代操作系统调度的最小单位，也可以叫轻量级进程，一个进程中可以创建多个线程，线程拥有各自的计数器，局部变量等，还可以访问共享的内存变量。

##### 过时的方法

- `suspend`挂起时不会释放占有的资源
- `stop`结束时也无法保证资源正确释放

##### 队列同步器(AQS)

- 用来构建锁或者其他同步组件，通过一个`int`的成员变量表示同步状态，内置一个`FIFO`队列完成资源获取线程的排队工作
- 主要通过继承使用，当用户需要实现自定义同步组件时，继承`Lock`接口，在类内部定义实现`AQS`的静态内部类，这也是`AQS`的作用，面向锁的实现者，简化锁的实现方式，只要实现几个具体的操作，实际调用模板方法
- 使用了模板方法模式，定义的执行的顺序和步骤，但是具体执行由用户自实现

- `AQS`内部通过一个同步队列来管理同步状态，如果一个线程没有获取到同步状态，同步器会将线程信息，等待信息等构造一个节点，用`CAS`操作放到队列的尾部.

##### 重入锁、读写锁

- 重入锁记录获取锁的线程及次数，下次还是当前线程获取的话，锁次数加一，同样如果是释放则次数减一，减到0时，释放锁
- 读写锁的实现很巧妙用户名，通过一个整形变量的高16位和低16位维护读写状态，高16位为读状态，低16位为写状态，通过位运算迅速确定相应状态，如与`0xffff`相`&`得出低16位
  - 读写锁支持锁降级，获取写锁，获取读锁，释放写锁，这样操作是防止，当前线程修改完之后，另外一个线程又想修改，进而阻塞了本次的读操作

##### CountDownLatch、CyclicBarrier

- `CountDownLatch`通过传入一个`int`类型的参数，作为计数器，要等待N个点完成，就传入N，N个点可以为N条线程，或者为一个线程中个N个操作步骤，N减到0的时候，调用`await`的地方就会继续往下执行，如果是等待多个线程的话，用`join`也可以实现，而且都可以在等待时候传入参数，指定等待时间，如果时间到了就不等了
- `CyclicBarrier`相当于是一根起跑线，等到所有的选手，也就是线程都就位后，再一起开始运行。还可以在构造时指定，达到阻塞数目的时候，优先运行指定的线程
- 区别
  - `CyclicBarrier`可以使用`reset`方法进行重置，而`CountDownLatch`只能运行一次，`Cyclicbarrier`能处理更复杂的业务，提供了如`getNumberWaiting`获取阻塞的线程数目这样的`api`

##### Semaphore

- 控制同时访问特定资源的线程，在构造方法中传入`int`数量，`acquire`获取许可，`release`归还

##### 线程池

- 一个线程被提交之后，首先判断核心线程池是否已满，没满创建工作线程执行任务，否则去检查工作队列是否已满，没满加入队列，否则再去检查是否已达到线程池最大数量，没到就创建线程执行，否则使用相应的饱和策略 
- `java`中的四种实现及使用场景
  - `FixedThreadPool`线程固定的线程池，适用于需要限制线程数量，负载较重的服务器
  - `SingleThreadExecutor`单个线程线程池，适用需要保证线程执行顺序的场景，但是无法满足多个线程同时执行的需求
  - `CachedThreadPool`是大小无界的线程池，默认会让执行完成的线程等待`60s`，如果没有任务来临那就终止该线程，使用执行很多短期异步小任务的场景，或者负载比较轻的服务器，错误使用可能会导致创建线程过多而耗尽资源
  - `ScheduledThreadPoolExecutor`
    - `ScheduledThreadPoolExecutor`，适合多个线程后台执行任务
    - 又可细分出`SingleThreadPoolExecutor`，适合单个线程执行任务且需要保证任务顺序执行

