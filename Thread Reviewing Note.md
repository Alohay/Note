##### Java 线程的实现

- `JDK1.2`之前是使用用户线程实现，后来替换为基于原生线程模型来实现
- `Sun JDK`在`windows, linux`上都是使用的轻量级进程（LWP）实现，一条`Java`线程映射到一个`LWP`中，因为操作系统提供的线程模型就是`1 ：1`

##### 锁

- 自旋锁
  - 请求锁的线程不放弃处理器时间，执行一个或多个忙循环，等共享数据的释放
- 自适应自旋
  - 如果之前通过自旋获得了这个锁，那这次允许多等一会，反之如果很少自旋成功，那么本次知己省略自旋的过程
- 锁消除
  - 虚拟机对于一些检测到一定不存在共享数据竞争的锁进行消除
- 锁粗化
  - 一系列操作对同一个对象反复加锁解锁，把加锁范围扩展到整个操作序列的外部，减少加锁次数
- 轻量级锁
  - 代码进入同步块的时候，如果同步对象没有被锁定，那么就在当前的栈帧中创建一个`Lock Record`存放锁对象头的`Mark Word`的拷贝，然后虚拟机尝试使用`CAS`操作将对象的`Mark Word` 更新为指向`Lock Record`的指针，更新成功则获得锁；失败的话，检查一下是不是指向当前线程的栈帧，如果是，那已经获得了锁，否则说明锁对象已被其他线程抢占。
  - 如果有两个以上的线程争用同一个锁，那就会锁膨胀，轻量级锁变重量级锁
- 偏向锁
  - 当锁对象第一次被获取时，虚拟机把对象头标志位`01`,并使用`CAS`操作将线程的`ID`记录到对象头中，若记录成功，则之后该线程每次进入锁同步块时，虚拟机可以不进行任何同步操作
  - 如果有别的线程尝试获取锁，那么偏向模式就解除了，根据锁对象的状态恢复成未锁定或轻量级锁的状态
  - 如果程序中大多数的锁都是存在竞争的，那么偏向模式就是多余的，禁用锁优化反而可以提高性能