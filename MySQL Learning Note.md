- `InnoDB`存储引擎

  - 支持事务，行锁，外键，实现了`SQL`的4种隔离级别，默认为可重复读，通过一种称为`next-key locking`的策略来避免幻读，表中数据的存储是按主键顺序的，如果表未显式定义主键，则依照定义顺序，寻找第一个`unique not null index`，未找到 则为每一行生成一个`RowID`，字段长度为6个字节，类型为长整形，作为主键
  - 主键最好用`int`自增，保证数据的顺序写入，与主键`B+索引`增长的顺序一致，利于根据主键的关联操作，性能会更好

- `MyIsAM`存储引擎

  - 不支持事务，表级锁，不支持外键，外键仅仅起到一个注释作用

- 自适应哈希索引（`Adaptive Hash Index AHI`）
    - 定义：`InnoDB`存储引擎会对表上索引页的查询监控，若观察到建立哈希索引可以带来速度提升，那就会建立哈希索引
    - 对某页多次连续相同的访问模式（即 `where`条件相同），完全由`InnoDB`存储引擎自己控制，可以设置是否启用该特性，默认开启

  - `InnoDB` 逻辑存储结构

      - 表空间 `->` 段 `->` 区 `->` 页 `->` 行
      - 表空间，默认情况下有表空间`ibdata1`，所有的数据存在该表空间中
          - 若启用了参数`innodb_file_pre_table`，则表上的数据，索引和插入缓冲`Bitmap`页会存放在每张表的表空间， 其他数据
          - ...

- 数据库约束
  - 关系数据库提供的约束机制是为了保证数据完整性
    - 实体完整性要求每张表要一个主键，若没有显示定义，看上文
    - 域完整性要求每列值满足特定的条件，非正常情况看下文
    - 参照完整性保证两表之间的关系，若定义外键则表明强制参照完整性
  - 默认情况下会将非法的值转成合法值再插入
    - 字段`NOT NULL`，插入 `NULL` 会转成`0`
    - 字段为`DATE`类型，插入 数字， 会 转成 `yyyy-MM-dd` 格式
    - 如果需要报错，那就要设置`sql_mode`，如可以设为`STRICT_TRANS_TABLES`
  - 唯一索引默认名称与列相同
  - `MySQL`不支持传统的`Check`约束，可以用`Enum`实现部分功能，如 性别
  - `MyISAM`存储引擎不支持外键，设置外键仅仅起一个注释的作用，`InnoDB`存储引擎的外键是真正起作用的，在`MySQL`中设置了外键，`InnoDB`会自动为该列设置一个`key`索引
    - `MySQL`数据库的外键是即时检查，导入数据时会每一行都进行检查，所以会导致在外键约束的检查上花费大量时间，当然可以在导入数据前关闭数据库对外键的检查，导入完成后再开启，这很麻烦，所以一般数据库优化中都会提及不要创建外键

- B+树
     - 中间节点不保存数据，只用来索引，数据均保存在叶子结点
     - 叶子结点保存了全部元素的信息，叶子结点上的数据是从小到大顺序链接的
     - 中间节点的元素在子节点中也存在，且是最大（最小）的元素
     - 查询性能较`B`树更稳定，每次查询都会找到叶子结点
     - 同样大小的页可以存放更多的中间节点，矮胖，减少`IO`次数
     - 范围查找十分简便，遍历链表即可

- 聚集索引
     - 内部是按主键构造（`InnoDB`数据按主键顺序存放）的`B+`树，数据全部存在其叶子结点上
     - 对于主键的排序查找和范围查找十分迅速
          - 比如查询最后10条记录，尽管`sql`语句中有`order by`但是并不会进行`filesort`操作，叶子结点是双向链表，所以能快速找到最后一个数据页，然后取出数据
          - 范围查找迅速是可以通过上层中间节点确定页的范围，直接读取数据页
     - 若需要对某张表创建聚集索引
          - 先创建一张临时表，表结构为`alter table`定义的新结构
          - 导入原表数据
          - 删除原表
          - 重命名临时表为原表

- 非聚集索引（辅助索引）
     - 叶子结点的`data`域指向数据记录的地址而不是记录本身，告诉`InnoDB`存储引擎哪里可以找到索引相对应的行数据 
     - 通过非聚集索引查询时，会遍历辅助索引获得指向主键索引的主键，然后通过主键索引获取到行记录
     - 非聚集索引的创建，在`5.5`版本后支持`Fast Index Creation`，创建时对表加上`S`锁，期间只允许对表进行读操作

- 什么时候创建`B+树`索引
     - 值的取值范围较大，几乎没有重复值，高选择性，若重复值高了，`SQL`查询时就有可能不走索引，达不到建索引优化的目的
     - 高选择性，可以通过 `show index from tableName` 查看 `index` 的 `cardinality` 属性，该值是大约表示了整张表中不同值的记录数（默认随机选取8个叶子结点，统计每个页中的不同记录所占百分比，求平均值，乘以总记录数），一般希望是 `该值/总记录数` 越接近 `1` 越好，该值并不是实时更新的，用两种更新策略，`1/16数据发了变化，stat_modified_counter（变化计数器）值大于20亿`

- 联合索引
     - 对多个列建立索引，`e.q. idx_clo_1_clo_2_clo_3(clo_1, clo_2, clo_3)`，建立`b+树`时根据`clo_1`排序再 `col_2` 再 `col_3`，所以单个`col_1`也是可以使用该索引的，而单个后面的列就不能使用该索引就是这个原因
     - 但是联合索引还有一个好处，因为会对第二列也进行排序，所以比如取出某用户最近的三次购物记录就会加快，避免了一次`filesort`排序

- 全文检索

     - 分词然后建立辅助表，生成关键字和出现位置（`DocumentID, 在文本中第几个单词`）的记录，关键字上有索引

     - 因为要分词所以需要有单词界定符，比如英文中空格，如果没有界定符，像中文日文之类的，就不支持

     - 一张表上只能建一个全文检索的索引

     - 查询语法是`where match(columnName) against('keyword' in xxx mode) // 默认是 natural language mode`  

          