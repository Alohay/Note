- `InnoDB`存储引擎

  - 支持事务，行锁，外键，普通读取（快照读，读回滚段里的数据）操作不加锁，实现了`SQL`的4种隔离级别，默认为可重复读，通过一种称为`next-key locking`的策略来避免幻读，表中数据的存储是按主键顺序的，如果表未显式定义主键，则依照定义顺序，寻找第一个`unique not null index`，未找到 则为每一行生成一个`RowID`，字段长度为6个字节，类型为长整形，作为主键
  - 主键最好用`int`自增，保证数据的顺序写入，与主键`B+索引`增长的顺序一致，利于根据主键的关联操作，性能会更好
- `MyIsAM`存储引擎

  - 不支持事务，表级锁，不支持外键，外键仅仅起到一个注释作用
  - 索引和数据分开存储，索引的叶子存储的是指针，主键索引和普通索引差不多
- 自适应哈希索引（`Adaptive Hash Index AHI`）
    - 定义：`InnoDB`存储引擎会对表上索引页的查询监控，若观察到建立哈希索引可以带来速度提升，那就会建立哈希索引
    - 对某页多次连续相同的访问模式（即 `where`条件相同），完全由`InnoDB`存储引擎自己控制，可以设置是否启用该特性，默认开启
  - `InnoDB` 逻辑存储结构

      - 表空间 `->` 段 `->` 区 `->` 页 `->` 行
      - 表空间，默认情况下有表空间`ibdata1`，所有的数据存在该表空间中
          - 若启用了参数`innodb_file_pre_table`，则表上的数据，索引和插入缓冲`Bitmap`页会存放在每张表的表空间， 其他数据
          - ...
- 数据库约束
  - 关系数据库提供的约束机制是为了保证数据完整性
    - 实体完整性要求每张表要一个主键，若没有显示定义，看上文
    - 域完整性要求每列值满足特定的条件，非正常情况看下文
    - 参照完整性保证两表之间的关系，若定义外键则表明强制参照完整性
  - 默认情况下会将非法的值转成合法值再插入
    - 字段`NOT NULL`，插入 `NULL` 会转成`0`
    - 字段为`DATE`类型，插入 数字， 会 转成 `yyyy-MM-dd` 格式
    - 如果需要报错，那就要设置`sql_mode`，如可以设为`STRICT_TRANS_TABLES`
  - 唯一索引默认名称与列相同
  - `MySQL`不支持传统的`Check`约束，可以用`Enum`实现部分功能，如 性别
  - `MyISAM`存储引擎不支持外键，设置外键仅仅起一个注释的作用，`InnoDB`存储引擎的外键是真正起作用的，在`MySQL`中设置了外键，`InnoDB`会自动为该列设置一个`key`索引
    - `MySQL`数据库的外键是即时检查，导入数据时会每一行都进行检查，所以会导致在外键约束的检查上花费大量时间，当然可以在导入数据前关闭数据库对外键的检查，导入完成后再开启，这很麻烦，所以一般数据库优化中都会提及不要创建外键
- B+树
     - 中间节点不保存数据，只用来索引，数据均保存在叶子结点
     - 叶子结点保存了全部元素的信息，叶子结点上的数据是从小到大顺序链接的
     - 中间节点的元素在子节点中也存在，且是最大（最小）的元素
     - 查询性能较`B`树更稳定，每次查询都会找到叶子结点
     - 同样大小的页可以存放更多的中间节点，矮胖，减少`IO`次数
     - 范围查找十分简便，遍历链表即可
- 聚集索引
     - 内部是按主键构造（`InnoDB`数据按主键顺序存放，注意无显示定义主键的情况）的`B+`树，数据全部存在其叶子结点上
     - 对于主键的排序查找和范围查找十分迅速
          - 比如查询最后10条记录，尽管`sql`语句中有`order by`但是并不会进行`filesort`操作，叶子结点是双向链表，所以能快速找到最后一个数据页，然后取出数据
          - 范围查找迅速是可以通过上层中间节点确定页的范围，直接读取数据页
     - 若需要对某张表创建聚集索引
          - 先创建一张临时表，表结构为`alter table`定义的新结构
          - 导入原表数据
          - 删除原表
          - 重命名临时表为原表
- 非聚集索引（辅助索引）
     - 叶子结点的`data`域指向数据记录的地址而不是记录本身，告诉`InnoDB`存储引擎哪里可以找到索引相对应的行数据 
     - 通过非聚集索引查询时，会遍历辅助索引获得指向主键索引的主键，然后通过主键索引获取到行记录
     - 非聚集索引的创建，在`5.5`版本后支持`Fast Index Creation`，创建时对表加上`S`锁，期间只允许对表进行读操作
- 什么时候创建`B+树`索引
     - 值的取值范围较大，几乎没有重复值，高选择性，若重复值高了，`SQL`查询时就有可能不走索引，达不到建索引优化的目的
     - 高选择性，可以通过 `show index from tableName` 查看 `index` 的 `cardinality` 属性，该值是大约表示了整张表中不同值的记录数（默认随机选取8个叶子结点，统计每个页中的不同记录所占百分比，求平均值，乘以总记录数），一般希望是 `该值/总记录数` 越接近 `1` 越好，该值并不是实时更新的，用两种更新策略，`1/16数据发了变化，stat_modified_counter（变化计数器）值大于20亿`
- 联合索引
     - 对多个列建立索引，`e.q. idx_clo_1_clo_2_clo_3(clo_1, clo_2, clo_3)`，建立`b+树`时根据`clo_1`排序再 `col_2` 再 `col_3`，所以单个`col_1`也是可以使用该索引的，而单个后面的列就不能使用该索引就是这个原因
     - 但是联合索引还有一个好处，因为会对第二列也进行排序，所以比如取出某用户最近的三次购物记录就会加快，避免了一次`filesort`排序
- 全文检索

     - 分词然后建立辅助表，生成关键字和出现位置（`DocumentID, 在文本中第几个单词`）的记录，关键字上有索引
     - 因为要分词所以需要有单词界定符，比如英文中空格，如果没有界定符，像中文日文之类的，就不支持
     - 一张表上只能建一个全文检索的索引
     - 查询语法是`where match(columnName) against('keyword' in xxx mode) // 默认是 natural language mode`  
- 数据多版本
     - 写任务发生时，将数据复制一份，用版本号区分，并发读任务可以继续读旧版本数据，而写任务操作新版本，直至提交
     - `redo`日志，因为事务提交后，按道理是要将更新后的日志刷到磁盘上，保证`ACID`特性，但是刷盘太慢了，所以先写到`redo`日志，然后定期刷盘，提高性能
     - `undo`日志，事务未提交的时候，会事务修改前的旧版本存到`undo`日志，回滚时或者崩溃时，利用`undo`日志，撤销未提交事务对数据库产生的影响
     - 回滚段，存放`undo`日志的地方，存放旧版本数据，`InnoDB`并发高，读取操作都是快照读，直接读回滚段的数据，若回滚段为空，说明没有写事务，可以直接读最新的数据，这样不违反一致性，因为读取到的记录，要么是已提交的事务产生的，要么是当前事务插入或修改了的
- 数据库锁

  - 自增锁，设置自增的键值，多个事务中插入是会互相阻塞的，因为要让同一事务中的插入值连续，所以自增锁是一种特殊的表锁
  - 共享锁/排他锁，共享锁（S锁，读锁），多个事务可以拿到一把S锁，读读可以并行，排它锁（X锁，写锁）只有一个事务能拿到，写写/读写互斥
  - 意向锁，表示未来的某个时刻，事务要加锁（S锁或X锁），提前声明，故有意向共享锁（IS），意向排它锁（IX锁），意向锁之间相互兼容，意向读锁与读锁兼容，其他两两均互斥
    - 意向锁协议要求：事务要获取某些行的S锁，必须先获得IS锁，要获取某些行的X锁，必须先获取IX锁
  - 插入意向锁，修改或删除需要X锁，插入不需要这么强的锁；插入意向锁是间隙锁（实施在索引上）的一种，需要注意的是，多个事务在同一个索引的同一个范围插入，如果位置不冲突，不会互相阻塞
  - 记录锁，封锁索引记录，阻止其他事务修改或删除这一行，`select * from table where id = 1 for update`
  - 间隙锁，封锁区间，如`select * from table where id between 1 and 10 for update`，防止其他事物在中间插入记录，但如果把事务等级降为读提交，那间隙锁则会失效
  - 临键锁，封锁索引记录本身以及索引记录之前的区间，避免幻读
- 常见问题
     - Q：为什么要索引？ A：提升数据库查找速度
     - Q：索引结构为什么要设计成树形，哈希不是更快吗？ A：这个其实是跟业务需求有关的，如果查询都是通过一个条件获取一条记录的话，确实应当使用哈希索引（`InnoDB`不支持），但是业务中有一些查询需要排序，分组，比较，范围查找，哈希索引的查找时间复杂度会退化成`O(n)`，而树型索引仍然能保持`O(log(n))`
     - Q：数据库索引为什么使用B+树？A：二叉树，数据量大了，高度就会很高，一次查询可能要多次磁盘`IO`查询比较慢；B树，其叶子节点和非叶子节点，都存储数据，每个节点有`k-1`个元素，中间节点有`k`个孩子，树相对来说会变得矮胖；B+树，数据全部存在叶子节点上，且有链表连接，所有查询都会找到叶子结点也就是说查询性能稳定，范围查找更快，而且中间节点不存储实际记录，相同内存情况下，一个非叶子结点能存储更多的索引，还有一个优点也是B树的优点，充分利用局部性原理，磁盘读写按页读取，大概率会用到附近的数据，减少未来的`IO`次数

