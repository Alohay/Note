- `SpringIOC` 
  - `ioc容器` 是 `Spring` 对依赖控制反转的一种实现，它可以在对象创建或初始化的时候将数据注入到对象中，或者直接注入到对象的数据域中，它把对象间的依赖有序的建立起来，降低代码耦合度
- `BeanFactory FactoryBean`
  - 所有的`Bean`都是由`BeanFactory`（也就是`IOC容器`）管理的
  - `FactoryBean`是一个特殊的`Bean`，能产生或修饰对象生成的工厂`Bean`
- `IOC`初始化流程
  - 分为三步， 第一步 `BeanDefinition`的`Resource资源`的定位，可以来自`FileSystem, ClassPath 或是 Web容器`，以打水这个行为举例，这步就是找到水源
  - 第二步，`BeanDefinition`的载入，把用户定义好的`Bean`表示成`Ioc`容器的内部数据结构，这个数据结构就是`BeanDefinition`
  - 第三步，`BeanDefinition`的注册，第二步的载入只是写入了一些静态的配置信息，严格来讲容器还没有完全起作用， 需要将`BeanDefinition`注册到一个`HashMap`中
  - 注册完成后初始化流程就完成了
  - 初始化过程主要是在`Ioc`容器中建立`BeanDefinition`的数据映射，而`Bean`之间的依赖关系还要依靠后面的依赖注入过程，当然如果指定了`lazy-init`属性，初始化过程会对`Bean`进行预实例化，这个实例化也是一个完成依赖注入的过程
  - 依赖注入一般是在用户首次向`Ioc容器`索要对象时触发，也就是调用了`getBean`方法，该方法中会获取当前`Bean`依赖的其他`Bean`，触发`getBean`的递归调用，最后返回一个依赖注入完成后的`Bean`



---

- `InnoDB`存储引擎
  - 支持事务，行锁，外键，默认读取不会产生锁，实现了`SQL`的4种隔离级别，默认为可重复读，提供了一种称为`next-key locking`的策略来避免幻读，表中数据的存储是按主键顺序的，如果表未显式定义主键，则依照定义顺序，寻找第一个`unique not null index`，未找到 则为每一行生成一个`RowID`，作为主键
- `MyIsAM`存储引擎
  - 不支持事务，表级锁，不支持外键，外键仅仅起到一个注释作用
- 自适应哈希索引（`Adaptive Hash Index AHI`）
    - 定义：`InnoDB`存储引擎会对表上索引页的查询监控，若观察到建立哈希索引可以带来速度提升，那就会建立哈希索引
    - 对某页多次连续相同的访问模式（即 `where`条件相同）
  - `InnoDB` 逻辑存储结构
      - 表空间 `->` 段 `->` 区 `->` 页 `->` 行
      - 表空间，默认情况下有表空间`ibdata1`，所有的数据存在该表空间中
          - 若启用了参数`innodb_file_pre_table`，则表上的数据，索引和插入缓冲`Bitmap`页会存放在每张表的表空间， 其他数据
          - ...
- 数据库约束
  - 关系数据库提供的约束机制是为了保证数据完整性
    - 实体完整性要求每张表要一个主键，若没有显示定义，看上文
    - 域完整性要求每列值满足特定的条件，非正常情况看下文
    - 参照完整性保证两表之间的关系，若定义外键则表明强制参照完整性
  - 默认情况下会将非法的值转成合法值再插入
    - 字段`NOT NULL`，插入 `NULL` 会转成`0`
    - 字段为`DATE`类型，插入 数字， 会 转成 `yyyy-MM-dd` 格式
    - 如果需要报错，那就要设置`sql_mode`，如可以设为`STRICT_TRANS_TABLES`
  - 唯一索引默认名称与列相同
  - `MySQL`不支持传统的`Check`约束，可以用`Enum`实现部分功能，如 性别
  - `MyISAM`存储引擎不支持外键，设置外键仅仅起一个注释的作用，`InnoDB`存储引擎的外键是真正起作用的，在`MySQL`中设置了外键，`InnoDB`会自动为该列设置一个`key`索引
    - `MySQL`数据库的外键是即时检查，导入数据时会每一行都进行检查，所以会导致在外键约束的检查上花费大量时间，当然可以在导入数据前关闭数据库对外键的检查，导入完成后再开启，这很麻烦，所以一般数据库优化中都会提及不要创建外键
- B+树
     - 中间节点不保存数据，只用来索引，数据均保存在叶子结点
     - 叶子结点保存了全部元素的信息，叶子结点上的数据是从小到大顺序链接的
     - 中间节点的元素在子节点中也存在，且是最大（最小）的元素
     - 查询性能较`B`树更稳定，每次查询都会找到叶子结点
     - 同样大小的页可以存放更多的中间节点，矮胖，减少`IO`次数
     - 范围查找十分简便，遍历链表即可
- 聚集索引
     - 内部是按主键构造（`InnoDB`数据按主键顺序存放）的`B+`树，其叶子结点存放的是一整行的信息
     - 对于主键的排序查找和范围查找十分迅速
          - 比如查询最后10条记录，尽管`sql`语句中有`order by`但是并不会进行`filesort`操作，叶子结点是双向链表，所以能快速找到最后一个数据页，然后取出数据
          - 范围查找迅速是可以通过上层中间节点确定页的范围，直接读取数据页
     - 若需要对某张表创建聚集索引
          - 先创建一张临时表，表结构为`alter table`定义的新结构
          - 导入原表数据
          - 删除原表
          - 重命名临时表为原表
- 非聚集索引（辅助索引）
     - 叶子结点除了键值外，还有一个书签，书签告诉`InnoDB`存储引擎哪里可以找到索引相对应的行数据 
     - 通过非聚集索引查询时，会遍历辅助索引获得指向主键索引的主键，然后通过主键索引获取到行记录
     - 非聚集索引的创建，在`5.5`版本后支持`Fast Index Creation`，创建时对表加上`S`锁，期间只允许对表进行读操作
- 什么时候创建`B+树`索引
     - 值的取值范围较大，几乎没有重复值，高选择性，若重复值高了，`SQL`查询时就有可能不走索引，达不到建索引优化的目的
     - 高选择性，可以通过 `show index from tableName` 查看 `index` 的 `cardinality` 属性，该值是大约表示了整张表中不同值的记录数（默认随机选取8个叶子结点，统计每个页中的不同记录所占百分比，求平均值，乘以总记录数），一般希望是 `该值/总记录数` 越接近 `1` 越好，该值并不是实时更新的，用两种更新策略，`1/16数据发了变化，stat_modified_counter（变化计数器）值大于20亿`
- 联合索引
     - 对多个列建立索引，`e.q. idx_clo_1_clo_2_clo_3(clo_1, clo_2, clo_3)`，建立`b+树`时根据`clo_1`排序再 `col_2` 再 `col_3`，所以单个`col_1`也是可以使用该索引的，而单个后面的列就不能使用该索引就是这个原因
     - 但是联合索引还有一个好处，因为会对第二列也进行排序，所以比如取出某用户最近的三次购物记录就会加快，避免了一次`filesort`排序
     - 